
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="Learn how to construct classical shadows and use them to estimate observables." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/atom_shadow.png" property="og:image" />

  

  <meta property="og:title" content="Classical Shadows &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_classical_shadows.html">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Learn how to construct classical shadows and use them to estimate observables." name="description" />
  

  <link href="https://fonts.googleapis.com/css?family=Noto+Serif" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">

  <!-- Material Design Bootstrap -->
  <!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/css/mdb.min.css" rel="stylesheet"> -->

  <!-- nanoscroller -->
  <link rel="stylesheet" type="text/css" href="../_static/css/nanoscroller.css" />

  <!-- lightslider -->
  <link type="text/css" rel="stylesheet" href="../_static/css/lightslider.min.css" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       SVG: { linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           bm: ['\\mathbf{\#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['I',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           diag: ['\\mathrm{diag} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0]
         }
       }
     });
     </script>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-130507810-1');
      </script>

  <title>Classical Shadows &#8212; PennyLane</title>
  
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/xanadu_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-rendered-html.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_classical_shadows.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quantum computation with neutral atoms" href="tutorial_pasqal.html" />
    <link rel="prev" title="Unitary Designs" href="tutorial_unitary_designs.html" /> 
  </head><body><link rel="stylesheet" type="text/css" href="../_static/xanadu_gallery.css" />
  <!--Navbar-->
<nav class="navbar navbar-expand-lg navbar-light white sticky-top">

  <!-- Navbar brand -->
  <a class="navbar-brand" href="https://pennylane.ai">
    <img class="pr-1" src="../_static/xanadu_x.png" width="28px"></img>
    <img src="../_static/pennylane.png" width="180px"></img>
  </a>

  <!-- Collapse button -->
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
    aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <!-- Collapsible content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links -->
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <a class="nav-link" href="https://pennylane.ai/qml">Quantum machine learning
          <span class="sr-only">(current)</span>
        </a>
      </li>
      <li class="nav-item">
        <a href="https://pennylane.ai/qml/demonstrations.html" class="nav-link">Demos</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://pennylane.ai/install.html">Install</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://pennylane.ai/plugins.html">Plugins</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://pennylane.readthedocs.io">Documentation</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://pennylane.ai/blog">Blog</a>
      </li>
      <li class="nav-item">
        <a class="nav-link q-hack-link" href="https://qhack.ai">
          <img src="https://pennylane.ai/img/qhack_plain_black.png">
        </a>
      </li>
    </ul>
    <!-- Links -->

    <ul class="navbar-nav ml-auto nav-flex-icons">
      <li class="nav-item">
        <a class="nav-link" href="http://pennylane.ai/faq.html">
          <i class="fab fas fa-question"></i> FAQ
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://discuss.pennylane.ai">
          <i class="fab fab fa-discourse"></i> Support
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://github.com/XanaduAI/PennyLane">
          <i class="fab fa-github"></i> GitHub
        </a>
      </li>
    </ul>
  </div>
  <!-- Collapsible content -->
</nav>
<!--/.Navbar-->

<script type="text/javascript">
var isDemoPages = window.location.pathname.includes('/demos_') || window.location.pathname.includes('/demonstrations') || window.location.pathname.includes('/demos/');

if (isDemoPages) {
  var $navItems = $('.nav-item');

  var previousActiveLink = $navItems.filter(function(index, item) {
    var $item = $(item);
    return $item.hasClass('active') && $item.innerText !== 'Demos';
  });

  if (previousActiveLink.length) $(previousActiveLink[0]).removeClass('active');

  var demoLink = $navItems.filter(function(index, item) {
    return item.innerText === 'Demos';
  });

  if (demoLink.length) $(demoLink[0]).addClass('active');
}
</script>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_pasqal.html" title="Quantum computation with neutral atoms"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_unitary_designs.html" title="Unitary Designs"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_quantum-computing.html" accesskey="U">Quantum Computing</a> &#187;</li> 
      </ul>
    </div>
        <div id="content">


          <div id="right-column">
            <div class="document clearer body">

              <div class="container-wrapper">

                <div role="navigation" aria-label="breadcrumbs navigation">
                  <ol class="breadcrumb">
                  </ol>
                </div>

              
  <div class="sphx-glr-download-link-note admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-classical-shadows-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="classical-shadows">
<span id="sphx-glr-demos-tutorial-classical-shadows-py"></span><h1>Classical Shadows<a class="headerlink" href="#classical-shadows" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_measurement_optimize.html", "quantum_volume.html", "tutorial_quantum_metrology.html"];
    var related_tutorials_titles = ['Measurement optimization', 'Quantum volume', 'Variationally optimizing measurement protocols'];
</script></p>
<p><em>Authors: Roeland Wiersema &amp; Brian Doolittle (Xanadu Residents).
Posted: 14 June 2021. Last updated: 14 June 2021.</em></p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/atom_shadow.png"><img alt="../_images/atom_shadow.png" src="../_images/atom_shadow.png" style="width: 75%;" /></a>
</div>
<p>Estimating properties of unknown quantum states is a key objective of quantum
information science and technology.
For example, one might want to check whether an apparatus prepares a particular target state,
or verify that an unknown system is entangled.
In principle, any unknown quantum state can be fully characterized by <a class="reference external" href="https://arxiv.org/pdf/quant-ph/0302028.pdf">quantum state
tomography</a> <a class="footnote-reference" href="#mauro2003" id="id1">[1]</a>.
However, this procedure requires accurate expectation values for a set of observables
whose size grows exponentially with the number of qubits.
A potential workaround for these scaling concerns is provided by the classical shadow approximation
introduced in a recent paper by Huang et al. <a class="footnote-reference" href="#huang2020" id="id2">[2]</a>.</p>
<p>The approximation is an efficient protocol for constructing a <em>classical shadow</em>
representation of an unknown quantum state.
The classical shadow can be used to estimate properties such as
quantum state fidelity, expectation values of Hamiltonians, entanglement witnesses, and two-point correlators.</p>
<div class="figure align-center" id="id8">
<a class="reference internal image-reference" href="../_images/classical_shadow_overview.png"><img alt="../_images/classical_shadow_overview.png" src="../_images/classical_shadow_overview.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">(Image from Huang et al. <a class="footnote-reference" href="#huang2020" id="id3">[2]</a>.)</span></p>
</div>
<p>In this demo, we use PennyLane to obtain classical shadows of a quantum state prepared by
a quantum circuit, and use them to reconstruct the state and estimate expectation values of
observables.</p>
<div class="section" id="constructing-a-classical-shadow">
<h2>Constructing a Classical Shadow<a class="headerlink" href="#constructing-a-classical-shadow" title="Permalink to this headline">¶</a></h2>
<p>Classical shadow estimation relies on the fact that for a particular choice of measurement,
we can efficiently store snapshots of the state that contain enough information to accurately
predict linear functions of observables. Depending on what type of measurements we choose,
we have an information-theoretic bound that allows us to control the precision of our estimator.</p>
<p>Let us consider an <span class="math notranslate nohighlight">\(n\)</span>-qubit quantum state <span class="math notranslate nohighlight">\(\rho\)</span> (prepared by a circuit) and apply a random unitary
<span class="math notranslate nohighlight">\(U\)</span> to the state:</p>
<div class="math notranslate nohighlight">
\[\rho \to U \rho U^\dagger.\]</div>
<p>Next, we measure in the computational basis and obtain a bit string of outcomes <span class="math notranslate nohighlight">\(|b\rangle = |0011\ldots10\rangle\)</span>.
If the unitaries <span class="math notranslate nohighlight">\(U\)</span> are chosen at random from a particular ensemble, then we can store the reverse operation
<span class="math notranslate nohighlight">\(U^\dagger |b\rangle\langle b| U\)</span> efficiently in classical memory.
We call this a <em>snapshot</em> of the state.
Moreover, we can view the average over these snapshots as a measurement channel:</p>
<div class="math notranslate nohighlight">
\[\mathbb{E}\left[U^\dagger |b\rangle\langle b| U\right] = \mathcal{M}(\rho).\]</div>
<p>If the ensemble of unitaries defines a tomographically complete set of measurements,
we can invert the channel and reconstruct the state:</p>
<div class="math notranslate nohighlight">
\[\rho = \mathbb{E}\left[\mathcal{M}^{-1}\left(U^\dagger |b\rangle\langle b| U \right)\right].\]</div>
<p>If we apply the procedure outlined above <span class="math notranslate nohighlight">\(N\)</span> times, then the collection of inverted snapshots
is what we call the <em>classical shadow</em></p>
<div class="math notranslate nohighlight">
\[S(\rho,N) = \left\{\hat{\rho}_1= \mathcal{M}^{-1}\left(U_1^\dagger |b_1\rangle\langle b_1| U_1 \right)
,\ldots, \hat{\rho}_N= \mathcal{M}^{-1}\left(U_N^\dagger |b_N\rangle\langle b_N| U_N \right)
\right\}.\]</div>
<p>The inverted channel is not physical, i.e., it is not completely postive and trace preserving (CPTP).
However, this is of no concern to us, since all we care about is efficiently applying this inverse channel to the
observed snapshots as a post-processing step.</p>
<p>Since the shadow approximates <span class="math notranslate nohighlight">\(\rho\)</span>, we can now estimate <strong>any</strong> observable with the empirical mean:</p>
<div class="math notranslate nohighlight">
\[\langle O \rangle = \frac{1}{N}\sum_i \text{Tr}{\hat{\rho}_i O}.\]</div>
<p>Note that the classical shadow is independent of the observables we want to estimate, as <span class="math notranslate nohighlight">\(S(\rho,N)\)</span> contains
only information about the state!</p>
<p>Furthermore, the authors of <a class="footnote-reference" href="#huang2020" id="id4">[2]</a> prove that with a shadow of size <span class="math notranslate nohighlight">\(N\)</span>, we can predict <span class="math notranslate nohighlight">\(M\)</span> arbitary linear functions
<span class="math notranslate nohighlight">\(\text{Tr}{O_1\rho},\ldots,\text{Tr}{O_M \rho}\)</span> up to an additive error <span class="math notranslate nohighlight">\(\epsilon\)</span> if <span class="math notranslate nohighlight">\(N\geq \mathcal{O}\left(\log{M} \max_i ||O_i||^2_{\text{shadow}}/\epsilon^2\right)\)</span>.
The shadow norm <span class="math notranslate nohighlight">\(||O_i||^2_{\text{shadow}}\)</span> depends on the unitary ensemble that is chosen.</p>
<p>Two different ensembles can be considered for selecting the random unitaries <span class="math notranslate nohighlight">\(U\)</span>:</p>
<ol class="arabic simple">
<li>Random <span class="math notranslate nohighlight">\(n\)</span>-qubit Clifford circuits.</li>
<li>Tensor products of random single-qubit Clifford circuits.</li>
</ol>
<p>Although ensemble 1 leads to the most powerful estimators, it comes with serious practical limitations
since <span class="math notranslate nohighlight">\(n^2 / \log(n)\)</span> entangling gates are required to sample the Clifford circuit. The snapshots of both ensembles
can be stored efficiently using the <a class="reference external" href="https://arxiv.org/abs/quant-ph/9705052">stabilizer formalism</a> <a class="footnote-reference" href="#gottesman1997" id="id5">[3]</a>.
Single-qubit Clifford circuits rotate the measurement basis to one of the Pauli eigenbases, so ensemble 2
is equivalent to measuring single shots of single-qubit Pauli observables on all qubits.
For the purposes of this demo we focus on ensemble 2, which is a more NISQ-friendly approach.</p>
<p>This ensemble comes with a significant drawback: the shadow norm <span class="math notranslate nohighlight">\(||O_i||^2_{\text{shadow}}\)</span>
becomes dependent on the locality <span class="math notranslate nohighlight">\(k\)</span> of the observables that we want to estimate:</p>
<div class="math notranslate nohighlight">
\[||O_i||^2_{\text{shadow}} \leq 4^k ||O_i||_\infty^2.\]</div>
<p>Say that we want to estimate the single expectation value of a Pauli observable
<span class="math notranslate nohighlight">\(\langle X_1 \otimes X_2 \otimes \ldots \otimes X_n \rangle\)</span>. Estimating this from repeated measurements
would require <span class="math notranslate nohighlight">\(1/\epsilon^2\)</span> samples, whereas we would need an exponentially large shadow due to the <span class="math notranslate nohighlight">\(4^n\)</span> appearing in the bound.
Therefore, classical shadows based on Pauli measurements only offer an advantage when we have to measure a large number
of observables with modest locality.</p>
<p>We will now demonstrate how to obtain classical shadows using PennyLane.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">import</span> <span class="nn">pennylane.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">666</span><span class="p">)</span>
</pre></div>
</div>
<p>A classical shadow is a collection of <span class="math notranslate nohighlight">\(N\)</span> individual snapshots <span class="math notranslate nohighlight">\(\hat{\rho}_i\)</span>.
Each snapshot is obtained with the following procedure:</p>
<ol class="arabic simple">
<li>The quantum state <span class="math notranslate nohighlight">\(\rho\)</span> is prepared with a circuit.</li>
<li>A unitary <span class="math notranslate nohighlight">\(U\)</span> is randomly selected from the ensemble and applied to <span class="math notranslate nohighlight">\(\rho\)</span>.</li>
<li>A computational basis measurement is performed.</li>
<li>The snapshot is recorded as the observed eigenvalue <span class="math notranslate nohighlight">\(1,-1\)</span> for <span class="math notranslate nohighlight">\(|0\rangle,|1\rangle\)</span>, respectively, and the index of the randomly selected unitary <span class="math notranslate nohighlight">\(U\)</span>.</li>
</ol>
<p>To obtain a classical shadow using PennyLane, we design the <code class="docutils literal notranslate"><span class="pre">calculate_classical_shadow</span></code>
function below.
This function obtains a classical shadow for the state prepared by an input
<code class="docutils literal notranslate"><span class="pre">circuit_template</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_classical_shadow</span><span class="p">(</span><span class="n">circuit_template</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">shadow_size</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a circuit, creates a collection of snapshots consisting of a bit string</span>
<span class="sd">    and the index of a unitary operation.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit_template (function): A Pennylane QNode.</span>
<span class="sd">        params (array): Circuit parameters.</span>
<span class="sd">        shadow_size (int): The number of snapshots in the shadow.</span>
<span class="sd">        num_qubits (int): The number of qubits in the circuit.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of two numpy arrays. The first array contains measurement outcomes (-1, 1)</span>
<span class="sd">        while the second array contains the index for the sampled Pauli&#39;s (0,1,2=X,Y,Z).</span>
<span class="sd">        Each row of the arrays corresponds to a distinct snapshot or sample while each</span>
<span class="sd">        column corresponds to a different qubit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># applying the single-qubit Clifford circuit is equivalent to measuring a Pauli</span>
    <span class="n">unitary_ensemble</span> <span class="o">=</span> <span class="p">[</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">,</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">,</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">]</span>

    <span class="c1"># sample random Pauli measurements uniformly, where 0,1,2 = X,Y,Z</span>
    <span class="n">unitary_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">shadow_size</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">))</span>
    <span class="n">outcomes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shadow_size</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shadow_size</span><span class="p">):</span>
        <span class="c1"># for each snapshot, add a random Pauli observable at each location</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="p">[</span><span class="n">unitary_ensemble</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">unitary_ids</span><span class="p">[</span><span class="n">ns</span><span class="p">,</span> <span class="n">i</span><span class="p">])](</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)]</span>
        <span class="n">outcomes</span><span class="p">[</span><span class="n">ns</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">circuit_template</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="n">obs</span><span class="p">)</span>

    <span class="c1"># combine the computational basis outcomes and the sampled unitaries</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">unitary_ids</span><span class="p">)</span>
</pre></div>
</div>
<p>As an example, we demonstrate how to use <code class="docutils literal notranslate"><span class="pre">calculate_classical_shadow</span></code> and
check its performance as the number of snapshots increases.
First, we will create a two-qubit device and a circuit that applies an
<code class="docutils literal notranslate"><span class="pre">RY</span></code> rotation to each qubit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># set up a two-qubit device with shots = 1 to ensure that we only get a single measurement</span>
<span class="n">dev</span> <span class="o">=</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># simple circuit to prepare rho</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">local_qubit_rotation_circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">observables</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;observable&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">dev</span><span class="o">.</span><span class="n">wires</span></a><span class="p">:</span>
        <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observables</span><span class="p">]</span>


<span class="c1"># arrays in which to collect data</span>
<span class="n">elapsed_times</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">shadows</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># collecting shadows and elapsed times</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">num_snapshots</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">shadow</span> <span class="o">=</span> <span class="n">calculate_classical_shadow</span><span class="p">(</span>
        <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">local_qubit_rotation_circuit</span></a><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">num_snapshots</span><span class="p">,</span> <span class="n">num_qubits</span>
    <span class="p">)</span>
    <span class="n">elapsed_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
    <span class="n">shadows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shadow</span><span class="p">)</span>

<span class="c1"># printing out the smallest shadow as an example</span>
<span class="nb">print</span><span class="p">(</span><span class="n">shadows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">shadows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[[ 1.  1.]
 [ 1.  1.]
 [ 1.  1.]
 [ 1.  1.]
 [ 1.  1.]
 [ 1.  1.]
 [ 1. -1.]
 [ 1.  1.]
 [ 1.  1.]
 [-1. -1.]]
[[2 2]
 [1 2]
 [0 1]
 [2 0]
 [0 2]
 [1 0]
 [2 0]
 [1 2]
 [0 1]
 [1 1]]
</pre></div>
</div>
<p>Observe that the shadow simply consists of two matrices.
Each qubit corresponds to a different column. The first matrix describes
outcome of the measurement
while the second matrix indexes the measurement applied to each qubit.
We now plot the computation times taken to acquire the shadows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">],</span> <span class="n">elapsed_times</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Time taken to obtain a classical shadow from a two-qubit state&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of Snapshots in Shadow&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Elapsed Time&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="Time taken to obtain a classical shadow from a two-qubit state" class="sphx-glr-single-img" src="../_images/sphx_glr_tutorial_classical_shadows_001.png" />
<p>As one might expect, the computation time increases linearly with the number
of snapshots.
This linear scaling is useful for predicting the length of time required to
obtain a sufficient number of snapshots for observable estimation.</p>
</div>
<div class="section" id="state-reconstruction-from-a-classical-shadow">
<h2>State Reconstruction from a Classical Shadow<a class="headerlink" href="#state-reconstruction-from-a-classical-shadow" title="Permalink to this headline">¶</a></h2>
<p>To verify that the classical shadow approximates the exact state that we want to estimate,
we tomographically reconstruct the original quantum state <span class="math notranslate nohighlight">\(\rho\)</span> from a classical
shadow. Remember that we can approximate <span class="math notranslate nohighlight">\(\rho\)</span> by averaging
over the snapshots and applying the inverse measurement channel,</p>
<div class="math notranslate nohighlight">
\[\rho = \mathbb{E}\left[\mathcal{M}^{-1}(U^{\dagger}|\hat{b}\rangle\langle\hat{b}|U)\right].\]</div>
<p>The expectation <span class="math notranslate nohighlight">\(\mathbb{E}[\cdot]\)</span> describes the average over the measurement outcomes
<span class="math notranslate nohighlight">\(|b\rangle\)</span> and the sampled unitaries.
Inverting the measurement channel may seem formidable at first, however, Huang et al.
<a class="footnote-reference" href="#huang2020" id="id6">[2]</a>
show that for Pauli measurements we end up with a rather convenient expression,</p>
<div class="math notranslate nohighlight">
\[\rho=\mathbb{E}[\hat{\rho}], \quad \text{where} \quad
\hat{\rho} = \bigotimes_{j=1}^n(3U^{\dagger}_j|\hat{b}_j\rangle\langle\hat{b}_j|U_j-\mathbb{I}).\]</div>
<p>Here <span class="math notranslate nohighlight">\(\hat{\rho}\)</span> is a snapshot state reconstructed from a single sample in the
classical shadow, and <span class="math notranslate nohighlight">\(\rho\)</span> is the average over all snapshot states <span class="math notranslate nohighlight">\(\hat{\rho}\)</span> in the
shadow.</p>
<p>To implement the state reconstruction of <span class="math notranslate nohighlight">\(\rho\)</span> in PennyLane, we develop the
<code class="docutils literal notranslate"><span class="pre">shadow_state_reconstruction</span></code> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">snapshot_state</span><span class="p">(</span><span class="n">b_list</span><span class="p">,</span> <span class="n">obs_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for `shadow_state_reconstruction` that reconstructs</span>
<span class="sd">     a state from a single snapshot in a shadow.</span>

<span class="sd">    Implements Eq. (S44) from https://arxiv.org/pdf/2002.08953.pdf</span>

<span class="sd">    Args:</span>
<span class="sd">        b_list (array): The list of classical outcomes for the snapshot.</span>
<span class="sd">        obs_list (array): Indices for the applied Pauli measurement.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Numpy array with the reconstructed snapshot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_list</span><span class="p">)</span>

    <span class="c1"># computational basis states</span>
    <span class="n">zero_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">one_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># local qubit unitaries</span>
    <span class="n">phase_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">hadamard</span> <span class="o">=</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span>
    <span class="n">identity</span> <span class="o">=</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.Identity.html#pennylane.Identity" title="pennylane.Identity" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Identity</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span>

    <span class="c1"># undo the rotations that were added implicitly to the circuit for the Pauli measurements</span>
    <span class="n">unitaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">hadamard</span><span class="p">,</span> <span class="n">hadamard</span> <span class="o">@</span> <span class="n">phase_z</span><span class="p">,</span> <span class="n">identity</span><span class="p">]</span>

    <span class="c1"># reconstructing the snapshot state from local Pauli measurements</span>
    <span class="n">rho_snapshot</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">zero_state</span> <span class="k">if</span> <span class="n">b_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">one_state</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">unitaries</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">obs_list</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>

        <span class="c1"># applying Eq. (S44)</span>
        <span class="n">local_rho</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">state</span> <span class="o">@</span> <span class="n">U</span><span class="p">)</span> <span class="o">-</span> <span class="n">identity</span>
        <span class="n">rho_snapshot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">rho_snapshot</span><span class="p">,</span> <span class="n">local_rho</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rho_snapshot</span>


<span class="k">def</span> <span class="nf">shadow_state_reconstruction</span><span class="p">(</span><span class="n">shadow</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a state approximation as an average over all snapshots in the shadow.</span>

<span class="sd">    Args:</span>
<span class="sd">        shadow (tuple): A shadow tuple obtained from `calculate_classical_shadow`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Numpy array with the reconstructed quantum state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_snapshots</span><span class="p">,</span> <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># classical values</span>
    <span class="n">b_lists</span><span class="p">,</span> <span class="n">obs_lists</span> <span class="o">=</span> <span class="n">shadow</span>

    <span class="c1"># Averaging over snapshot states.</span>
    <span class="n">shadow_rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="n">num_qubits</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">num_qubits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_snapshots</span><span class="p">):</span>
        <span class="n">shadow_rho</span> <span class="o">+=</span> <span class="n">snapshot_state</span><span class="p">(</span><span class="n">b_lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">obs_lists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">shadow_rho</span> <span class="o">/</span> <span class="n">num_snapshots</span>
</pre></div>
</div>
<div class="section" id="example-reconstructing-a-bell-state">
<h3>Example: Reconstructing a Bell State<a class="headerlink" href="#example-reconstructing-a-bell-state" title="Permalink to this headline">¶</a></h3>
<p>First, we construct a single-shot, <code class="docutils literal notranslate"><span class="pre">'default.qubit'</span></code> device and
define the <code class="docutils literal notranslate"><span class="pre">bell_state_circuit</span></code> QNode to construct and measure a Bell state.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">dev</span> <span class="o">=</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># circuit to create a Bell state and measure it in</span>
<span class="c1"># the bases specified by the &#39;observable&#39; keyword argument.</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bell_state_circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">observables</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;observable&quot;</span><span class="p">)</span>

    <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">[</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observables</span><span class="p">]</span>
</pre></div>
</div>
<p>Then, construct a classical shadow consisting of 1000 snapshots.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_snapshots</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">shadow</span> <span class="o">=</span> <span class="n">calculate_classical_shadow</span><span class="p">(</span>
    <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bell_state_circuit</span></a><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">num_snapshots</span><span class="p">,</span> <span class="n">num_qubits</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">shadow</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[[ 1. -1.]
 [ 1. -1.]
 [ 1. -1.]
 ...
 [ 1. -1.]
 [-1.  1.]
 [ 1.  1.]]
[[1 0]
 [0 1]
 [2 0]
 ...
 [1 1]
 [1 1]
 [0 2]]
</pre></div>
</div>
<p>To reconstruct the Bell state we use <code class="docutils literal notranslate"><span class="pre">shadow_state_reconstruction</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shadow_state</span> <span class="o">=</span> <span class="n">shadow_state_reconstruction</span><span class="p">(</span><span class="n">shadow</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">shadow_state</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[[ 0.50275+0.j       0.0285 -0.02325j  0.06375+0.j       0.4995 -0.00675j]
 [ 0.0285 +0.02325j -0.01925+0.j       0.027  -0.00675j -0.04425-0.018j  ]
 [ 0.06375-0.j       0.027  +0.00675j -0.05675+0.j       0.006  +0.00375j]
 [ 0.4995 +0.00675j -0.04425+0.018j    0.006  -0.00375j  0.57325+0.j     ]]
</pre></div>
</div>
<p>Note the resemblance to the exact Bell state density matrix.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bell_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
</pre></div>
</div>
<p>To measure the closeness we can use the operator norm.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">operator_2_norm</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the operator 2-norm.</span>

<span class="sd">    Args:</span>
<span class="sd">        R (array): The operator whose norm we want to calculate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Scalar corresponding to the norm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">R</span><span class="p">))</span>


<span class="c1"># Calculating the distance between ideal and shadow states.</span>
<span class="n">operator_2_norm</span><span class="p">(</span><span class="n">bell_state</span> <span class="o">-</span> <span class="n">shadow_state</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>(0.16156422871415568+0j)
</pre></div>
</div>
<p>Finally, we see how the approximation improves as we increase the
number of snapshots. We run the estimator 10 times for each <span class="math notranslate nohighlight">\(N\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">number_of_runs</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">snapshots_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">6000</span><span class="p">]</span>
<span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_of_runs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">snapshots_range</span><span class="p">)))</span>

<span class="c1"># run the estimation multiple times so that we can include error bars</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_runs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">num_snapshots</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snapshots_range</span><span class="p">):</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">calculate_classical_shadow</span><span class="p">(</span>
            <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bell_state_circuit</span></a><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">num_snapshots</span><span class="p">,</span> <span class="n">num_qubits</span>
        <span class="p">)</span>
        <span class="n">shadow_state</span> <span class="o">=</span> <span class="n">shadow_state_reconstruction</span><span class="p">(</span><span class="n">shadow</span><span class="p">)</span>

        <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">operator_2_norm</span><span class="p">(</span><span class="n">bell_state</span> <span class="o">-</span> <span class="n">shadow_state</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
    <span class="n">snapshots_range</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">yerr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Distance between Ideal and Shadow Bell States&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of Snapshots&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Distance&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="Distance between Ideal and Shadow Bell States" class="sphx-glr-single-img" src="../_images/sphx_glr_tutorial_classical_shadows_002.png" />
<p>As expected, when the number of snapshots increases, the state reconstruction
becomes closer to the ideal state.</p>
</div>
</div>
<div class="section" id="estimating-pauli-observables-with-classical-shadows">
<h2>Estimating Pauli Observables with Classical Shadows<a class="headerlink" href="#estimating-pauli-observables-with-classical-shadows" title="Permalink to this headline">¶</a></h2>
<p>We have confirmed that classical shadows can be used to reconstruct
the state. However, the goal of classical shadows is not to perform full tomography, which takes
an exponential amount of resources. Instead, we want to use the shadows to efficiently
calculate linear functions of a quantum state. To do this, we write a function
<code class="docutils literal notranslate"><span class="pre">estimate_shadow_observable</span></code> that takes in the previously constructed shadow
<span class="math notranslate nohighlight">\(S(\rho, N)=[\hat{\rho}_1,\hat{\rho}_2,\ldots,\hat{\rho}_N]\)</span>, and
estimates any observable via a median of means estimation. This makes the estimator
more robust to outliers and is required to formally prove the aforementioned theoretical
bound. The procedure is simple: split up the shadow into <span class="math notranslate nohighlight">\(K\)</span> equally sized chunks
and estimate the mean for each of these chunks,</p>
<div class="math notranslate nohighlight">
\[\langle O_{(k)}\rangle = \text{Tr}\{O \hat{\rho}_{(k)}\} \quad
\text{and} \quad \hat{\rho}_{(k)} = \frac{1}{ \lfloor N/K \rfloor }
\sum_{i=(k-1)\lfloor N/K \rfloor + 1}^{k \lfloor N/K \rfloor } \hat{\rho}_i.\]</div>
<p>The median of means estimator is then simply the median of this set</p>
<div class="math notranslate nohighlight">
\[\langle O\rangle = \text{median}\{\langle O_{(1)} \rangle,\ldots, \langle O_{(K)} \rangle \}.\]</div>
<p>Note that the shadow bound has a failure probability <span class="math notranslate nohighlight">\(\delta\)</span>. By choosing the number of splits <span class="math notranslate nohighlight">\(K\)</span> to be
suitably large, we can exponentially suppress this failure probability.
Assume now that <span class="math notranslate nohighlight">\(O=\bigotimes_j^n P_j\)</span>, where <span class="math notranslate nohighlight">\(P_j \in \{I, X, Y, Z\}\)</span>.
To efficiently calculate the estimator for <span class="math notranslate nohighlight">\(O\)</span>, we look at a single snapshot outcome and plug in the inverse measurement channel:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{Tr}\{O\hat{\rho}_i\} &amp;= \text{Tr}\{\bigotimes_{j=1}^n P_j (3U^{\dagger}_j|\hat{b}_j\rangle\langle\hat{b}_j|U_j-\mathbb{I})\}\\
 &amp;= \prod_j^n \text{Tr}\{ 3 P_j U^{\dagger}_j|\hat{b}_j\rangle\langle\hat{b}_j|U_j\}.\end{split}\]</div>
<p>Due to the orthogonality of the Pauli operators, this evaluates to <span class="math notranslate nohighlight">\(\pm 3\)</span> if <span class="math notranslate nohighlight">\(P_j\)</span> is the
corresponding measurement basis <span class="math notranslate nohighlight">\(U_j\)</span> and 0 otherwise. Hence if a single <span class="math notranslate nohighlight">\(U_j\)</span> in the snapshot
does not match the one in <span class="math notranslate nohighlight">\(O\)</span>, the whole product evaluates to zero. As a result, calculating the mean estimator
can be reduced to counting the number of exact matches in the shadow with the observable, and multiplying with the appropriate
sign. Below, we develop the function <code class="docutils literal notranslate"><span class="pre">estimate_shadow_obervable</span></code> to estimate any observable given a classical shadow.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">estimate_shadow_obervable</span><span class="p">(</span><span class="n">shadow</span><span class="p">,</span> <span class="n">observable</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adapted from https://github.com/momohuang/predicting-quantum-properties</span>
<span class="sd">    Calculate the estimator E[O] = median(Tr{rho_{(k)} O}) where rho_(k)) is set of k</span>
<span class="sd">    snapshots in the shadow. Use median of means to ameliorate the effects of outliers.</span>

<span class="sd">    Args:</span>
<span class="sd">        shadow (tuple): A shadow tuple obtained from `calculate_classical_shadow`.</span>
<span class="sd">        observable (qml.Observable): Single PennyLane observable consisting of single Pauli</span>
<span class="sd">            operators e.g. qml.PauliX(0) @ qml.PauliY(1).</span>
<span class="sd">        k (int): number of splits in the median of means estimator.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Scalar corresponding to the estimate of the observable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shadow_size</span><span class="p">,</span> <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># convert Pennylane observables to indices</span>
    <span class="n">map_name_to_int</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;PauliX&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;PauliY&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;PauliZ&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observable</span><span class="p">,</span> <span class="p">(</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">,</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">,</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">)):</span>
        <span class="n">target_obs</span><span class="p">,</span> <span class="n">target_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">map_name_to_int</span><span class="p">[</span><span class="n">observable</span><span class="o">.</span><span class="n">name</span><span class="p">]]</span>
        <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">observable</span><span class="o">.</span><span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_obs</span><span class="p">,</span> <span class="n">target_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">map_name_to_int</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observable</span><span class="o">.</span><span class="n">obs</span><span class="p">]</span>
        <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observable</span><span class="o">.</span><span class="n">obs</span><span class="p">])</span>

    <span class="c1"># classical values</span>
    <span class="n">b_lists</span><span class="p">,</span> <span class="n">obs_lists</span> <span class="o">=</span> <span class="n">shadow</span>
    <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># loop over the splits of the shadow:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow_size</span><span class="p">,</span> <span class="n">shadow_size</span> <span class="o">//</span> <span class="n">k</span><span class="p">):</span>

        <span class="c1"># assign the splits temporarily</span>
        <span class="n">b_lists_k</span><span class="p">,</span> <span class="n">obs_lists_k</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">b_lists</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">shadow_size</span> <span class="o">//</span> <span class="n">k</span><span class="p">],</span>
            <span class="n">obs_lists</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">shadow_size</span> <span class="o">//</span> <span class="n">k</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># find the exact matches for the observable of interest at the specified locations</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">obs_lists_k</span><span class="p">[:,</span> <span class="n">target_locs</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># catch the edge case where there is no match in the chunk</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># take the product and sum</span>
            <span class="n">product</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">b_lists_k</span><span class="p">[</span><span class="n">indices</span><span class="p">][:,</span> <span class="n">target_locs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">product</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we can define a function that calculates the number of samples
required to get an error <span class="math notranslate nohighlight">\(\epsilon\)</span> on our estimator for a given set of observables.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">shadow_bound</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">observables</span><span class="p">,</span> <span class="n">failure_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the shadow bound for the Pauli measurement scheme.</span>

<span class="sd">    Implements Eq. (S13) from https://arxiv.org/pdf/2002.08953.pdf</span>

<span class="sd">    Args:</span>
<span class="sd">        error (float): The error on the estimator.</span>
<span class="sd">        observables (list) : List of matrices corresponding to the observables we intend to</span>
<span class="sd">            measure.</span>
<span class="sd">        failure_rate (float): Rate of failure for the bound to hold.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An integer that gives the number of samples required to satisfy the shadow bound and</span>
<span class="sd">        the chunk size required attaining the specified failure rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observables</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span> <span class="o">/</span> <span class="n">failure_rate</span><span class="p">)</span>
    <span class="n">shadow_norm</span> <span class="o">=</span> <span class="p">(</span>
        <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
            <span class="n">op</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="p">)</span>
        <span class="o">**</span> <span class="mi">2</span>
    <span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">34</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">shadow_norm</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observables</span><span class="p">)</span> <span class="o">/</span> <span class="n">error</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">K</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="example-estimating-a-simple-set-of-observables">
<h3>Example: Estimating a simple set of observables<a class="headerlink" href="#example-estimating-a-simple-set-of-observables" title="Permalink to this headline">¶</a></h3>
<p>Here, we give an example for estimating multiple observables on a 10-qubit circuit.
We first create a simple circuit</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">dev</span> <span class="o">=</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">observables</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;observable&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">):</span>
        <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">dev</span><span class="o">.</span><span class="n">wires</span></a><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">dev</span><span class="o">.</span><span class="n">wires</span></a><span class="p">:</span>
        <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">w</span> <span class="o">+</span> <span class="n">num_qubits</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observables</span><span class="p">]</span>


<span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_qubits</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we define our set of observables</p>
<div class="math notranslate nohighlight">
\[O = \sum_{i=0}^{n-1} X_i X_{i+1} + Y_i Y_{i+1} + Z_i Z_{i+1}.\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">list_of_observables</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">[</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">@</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="o">+</span> <span class="p">[</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">@</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="o">+</span> <span class="p">[</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">@</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">shadow_bound</span></code> function, we calculate how many shadows we need to
ensure that the absolute error of all individual terms in <span class="math notranslate nohighlight">\(O\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[|\langle{O_i}\rangle_{shadow} - \langle{O_i}\rangle_{exact}| \leq \epsilon\]</div>
<p>for all <span class="math notranslate nohighlight">\(1\leq i \leq M\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shadow_size_bound</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">shadow_bound</span><span class="p">(</span>
    <span class="n">error</span><span class="o">=</span><span class="mf">2e-1</span><span class="p">,</span> <span class="n">observables</span><span class="o">=</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">matrix</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">list_of_observables</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">shadow_size_bound</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>14611
</pre></div>
</div>
<p>We verify the bound by considering a grid of errors <span class="math notranslate nohighlight">\(\epsilon_i\)</span> and checking that
<span class="math notranslate nohighlight">\(|\langle{O_i}\rangle_{shadow} - \langle{O_i}\rangle_{exact}|\)</span> stays below this value
for the shadow size calculated in <code class="docutils literal notranslate"><span class="pre">shadow_bound</span></code>. First, we get the classical shadow estimate.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># create a grid of errors</span>
<span class="n">epsilon_grid</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>
<span class="n">shadow_sizes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">epsilon_grid</span><span class="p">:</span>
    <span class="c1"># get the number of samples needed so that the absolute error &lt; epsilon.</span>
    <span class="n">shadow_size_bound</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">shadow_bound</span><span class="p">(</span>
        <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">observables</span><span class="o">=</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">matrix</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">list_of_observables</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">shadow_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shadow_size_bound</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">shadow_size_bound</span><span class="si">}</span><span class="s2"> samples required &quot;</span><span class="p">)</span>
    <span class="c1"># calculate a shadow of the appropriate size</span>
    <span class="n">shadow</span> <span class="o">=</span> <span class="n">calculate_classical_shadow</span><span class="p">(</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit</span></a><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">shadow_size_bound</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>

    <span class="c1"># estimate all the observables in O</span>
    <span class="n">estimates</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">estimate_shadow_obervable</span><span class="p">(</span><span class="n">shadow</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">list_of_observables</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>585 samples required
722 samples required
914 samples required
1193 samples required
1624 samples required
2338 samples required
3653 samples required
6494 samples required
14611 samples required
</pre></div>
</div>
<p>Then, we calculate the ground truth by changing the device backend.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev_exact</span> <span class="o">=</span> <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="c1"># change the simulator to be the exact one.</span>
<a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit</span></a><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">dev_exact</span>
<span class="n">expval_exact</span> <span class="o">=</span> <span class="p">[</span>
    <a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit</span></a><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">dev_exact</span><span class="o">.</span><span class="n">wires</span></a><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="p">[</span><span class="n">o</span><span class="p">])</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">list_of_observables</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Finally, we plot the errors <span class="math notranslate nohighlight">\(|\langle{O_i}\rangle_{shadow} - \langle{O_i}\rangle_{exact}|\)</span>
for all individual terms in <span class="math notranslate nohighlight">\(O\)</span>. We expect that these errors are always smaller than <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epsilon_grid</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
        <span class="p">[</span><span class="n">shadow_sizes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">estimates</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">obs</span> <span class="o">-</span> <span class="n">estimates</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expval_exact</span><span class="p">)],</span>
        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">shadow_sizes</span><span class="p">,</span>
    <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epsilon_grid</span><span class="p">],</span>
    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="sa">rf</span><span class="s2">&quot;$\epsilon$&quot;</span><span class="p">,</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$N$ (Shadow size) &quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$|\langle O_i \rangle_</span><span class="si">{exact}</span><span class="s2"> - \langle O_i \rangle_</span><span class="si">{shadow}</span><span class="s2">|$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="tutorial classical shadows" class="sphx-glr-single-img" src="../_images/sphx_glr_tutorial_classical_shadows_003.png" />
<p>The points in the plot indicate the individual errors for all <span class="math notranslate nohighlight">\(O_i\)</span> at a given shadow size. The dashed line
represents the error threshold that these points must stay under to satisfy the bound.
As expected, the bound is satisfied for all <span class="math notranslate nohighlight">\(O_i\)</span> and the errors decrease with the size of
the shadow.</p>
<p>To conclude, we have shown that classical shadows can be used to reconstruct quantum states and
estimate expectation values of observables. This is but the tip of the iceberg of what is possible
with this technique. In the original work <a class="footnote-reference" href="#huang2020" id="id7">[2]</a>, the authors estimate fidelities,
calculate entanglement witnesses, and even find a way to approximate the von Neumann entropy.
These applications illustrate the potential power
of classical shadows for the characterization of quantum systems.</p>
<table class="docutils footnote" frame="void" id="mauro2003" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>G. Mauro D’Ariano, Matteo G.A. Paris, Massimiliano F. Sacchi,
<a class="reference external" href="https://arxiv.org/pdf/quant-ph/0302028.pdf">“Quantum Tomography”</a>,
Advances in Imaging and Electron Physics, 128 (2003): 205-308.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="huang2020" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>, <a class="fn-backref" href="#id4">3</a>, <a class="fn-backref" href="#id6">4</a>, <a class="fn-backref" href="#id7">5</a>)</em> Huang, Hsin-Yuan, Richard Kueng, and John Preskill,
<a class="reference external" href="https://arxiv.org/pdf/2002.08953.pdf">“Predicting many properties of a quantum system from very few measurements”</a>,
Nature Physics 16.10 (2020): 1050-1057.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gottesman1997" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Gottesman, Daniel,
<a class="reference external" href="https://arxiv.org/abs/quant-ph/9705052">“Stabilizer Codes and Quantum Error Correction”,</a>
Ph.D. thesis, Caltech, eprint quantph/9705052.</td></tr>
</tbody>
</table>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 5 minutes  20.977 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-classical-shadows-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<a class="reference download internal" download="" href="../_downloads/ddd317f0673fc27b73802872c6b58cc0/tutorial_classical_shadows.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_classical_shadows.py</span></code></a></div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<a class="reference download internal" download="" href="../_downloads/44248672cea98ca9eee91c6d6930ad1f/tutorial_classical_shadows.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_classical_shadows.ipynb</span></code></a></div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>
</div>


              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_classical_shadows</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>
            </div>
          </div>
              <div class="comment-container nano has-scrollbar">
  <div class="nano-content">
    
    <div id="comments">
      <h3>Contents</h3>
      <ul>
<li><a class="reference internal" href="#">Classical Shadows</a><ul>
<li><a class="reference internal" href="#constructing-a-classical-shadow">Constructing a Classical Shadow</a></li>
<li><a class="reference internal" href="#state-reconstruction-from-a-classical-shadow">State Reconstruction from a Classical Shadow</a><ul>
<li><a class="reference internal" href="#example-reconstructing-a-bell-state">Example: Reconstructing a Bell State</a></li>
</ul>
</li>
<li><a class="reference internal" href="#estimating-pauli-observables-with-classical-shadows">Estimating Pauli Observables with Classical Shadows</a><ul>
<li><a class="reference internal" href="#example-estimating-a-simple-set-of-observables">Example: Estimating a simple set of observables</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    <div class="xanadu-call-to-action-links">
      <h3>Downloads</h3>
      <div id="tutorial-type">demos/tutorial_classical_shadows</div>
      <div class="download-python-link">
        <i class="fab fa-python"></i>&nbsp;
        <div class="call-to-action-desktop-view">Download Python script</div>
      </div>
      <div class="download-notebook-link">
        <i class="fas fa-download"></i>&nbsp;
        <div class="call-to-action-desktop-view">Download Notebook</div>
      </div>
      <div class="github-view-link">
        <i class="fab fa-github"></i>&nbsp;
        <div class="call-to-action-desktop-view">View on GitHub</div>
      </div>
      <div id="related-tutorials" class="mt-4">
      <h3> Related tutorials</h3>
      </div>
    </div>
  </div>
</div>
            

          <div class="up-button">
            
              
                <a href="../demos_quantum-computing.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>


    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_pasqal.html" title="Quantum computation with neutral atoms"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_unitary_designs.html" title="Unitary Designs"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_quantum-computing.html" >Quantum Computing</a> &#187;</li> 
      </ul>
    </div>

    <!-- JQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <!-- Bootstrap core JavaScript -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- MDB core JavaScript -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
    <!-- Nanoscroller -->
    <script type="text/javascript" src="../_static/js/nanoscroller.min.js"></script>
    <script type="text/javascript">
        $('a.reference.external').each(function(){
          var link = $(this).attr("href");
          var hash = link.split('#')[1];
          var page = link.split('#')[0].split('/').slice(-1)[0].replace(".html", "");
          if (hash == page) {
            $(this).attr('href', link.split('#')[0]);
          }
        });
        $(".document > .section").removeClass("section");
        var tocContainer = document.querySelector('.comment-container');
        tocContainer.style.height = '85vh';
        $(".nano").nanoScroller();
    </script>
    <!-- lightslider -->
    <script src="../_static/js/lightslider.min.js"></script>

    <script type="text/javascript">
      $(window).scroll(function(){
          var windowHeight = window.innerHeight;
          var footer = document.querySelector('.page-footer');
          var footerPosition = footer.getBoundingClientRect();
          var tocContainer = document.querySelector('.comment-container');

          // Check if the footer is visible
          if (footerPosition.top < windowHeight && footerPosition.bottom >= 0) {
              // We want the height of the TOC to be the height of the main content minus how much of the footer is visible.
              tocContainer.style.height = 'calc(85vh - 45px - ' + (windowHeight - footerPosition.top) + 'px)'
          } else {
            // When the user scrolls back to the top of the page after scrolling to the bottom of the page,
            // We want to reset the TOC container back to it's original height
            if (tocContainer.style.height !== '85vh') tocContainer.style.height = '85vh';
          }
      });
      $(document).ready(function () {
          $(".css-transitions-only-after-page-load").each(function (index, element) {
              setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
          });
      });
    </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "XanaduAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href,
          notebookDownloadPath = notebookLink.split('_downloads')[1].split('/').pop();

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();
      }
    </script>


    <script type="text/javascript">
        $(document).ready(function() {
            $("#featured-demos").lightSlider({
                item: 3,
                autoWidth: false,
                slideMove: 1, // slidemove will be 1 if loop is true
                slideMargin: 0,
                auto: true,
                loop: true,
                controls: true,
                pause: 5000,
                pager: false,
                prevHtml: "<i class='fas fa-chevron-left black-text' style='font-size: xx-large;'></i>",
                nextHtml: "<i class='fas fa-chevron-right black-text' style='font-size: xx-large;'></i>",
                responsive : [
                    {
                        breakpoint:1400,
                        settings: {
                            item:2,
                            slideMove:1,
                            slideMargin:0,
                          }
                    },
                    {
                        breakpoint:768,
                        settings: {
                            item:1,
                            slideMove:1,
                            slideMargin:6,
                          }
                    }
                ]
            });
        });
    </script>


  <footer class="page-footer text-md-left pt-4">
  
    <hr class="pb-0 mb-0">
    <div class="container-fluid">
      <div class="row   justify-content-md-center">
        <div class="col-md-3">
          <h5 class=" mb-1 footer-heading">Xanadu</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <p class="">Located in the heart of downtown Toronto, we've brought together exceptional minds from around the world to build quantum computers that are useful and available to people everywhere.</p>
        </div>

    <div class="col-md-2 col-4">
          <h5 class=" mb-1 footer-heading">PennyLane</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <ul class="list-unstyled">
            <li><a class="" href="https://pennylane.ai/">Home page</a></li>
            <li><a class="" href="https://github.com/XanaduAI/pennylane">GitHub</a></li>
            <li><a class="" href="https://pennylane.readthedocs.io/">Documentation</a></li>
            <li><a class="" href="https://discuss.pennylane.ai/">Discussion forum</a></li>
            <li><a class="" href="https://twitter.com/pennylaneai/">Twitter</a></li>
          </ul>
        </div>
		<div class="col-md-2 col-4">
          <h5 class=" mb-1 footer-heading">Strawberry Fields</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <ul class="list-unstyled">
            <li><a class="" href="https://strawberryfields.ai/">Interactive</a></li>
            <li><a class="" href="https://github.com/XanaduAI/strawberryfields">GitHub</a></li>
            <li><a class="" href="https://strawberryfields.readthedocs.io/">Documentation</a></li>
            <li><a class="" href="https://u.strawberryfields.ai/slack/">Slack channel</a></li>
          </ul>
        </div>


        <div class="col-md-2 col-4">
          <h5 class=" mb-1 footer-heading">About</h5>
          <hr width=100px class="d-inline-block mt-0 mb-1 Deep-purple accent-4">
          <ul class="list-unstyled">
            <li><a class="" href="https://www.xanadu.ai/">Home</a></li>
            <li><a class="" href="https://www.xanadu.ai/hardware/">Hardware</a></li>
            <li><a class="" href="https://www.xanadu.ai/software/">Software</a></li>
            <li><a class="" href="https://www.xanadu.ai/research">Research</a></li>
            <li><a class="" href="https://medium.com/XanaduAI">Blog</a></li>
            <li><a class="" href="https://www.xanadu.ai/about/">About</a></li>
          </ul>
        </div>
      </div>
    </div>
    <hr>

    <!-- <hr class="pb-0 mb-0"> -->

    <!--Social buttons-->
    <div class="social-section text-center">
        <ul class="list-unstyled list-inline mb-0">
            <li class="list-inline-item"><a class="btn-fb" href="https://www.facebook.com/Xanadu-1312050742230493/"><i class="fab fa-facebook-f"> </i></a></li>
            <li class="list-inline-item"><a class="btn-tw" href="https://twitter.com/xanaduai"><i class="fab fa-twitter"> </i></a></li>
            <li class="list-inline-item"><a class="" href="https://medium.com/xanaduai"><i class="fab fa-medium-m"> </i></a></li>
            <li class="list-inline-item"><a class="btn-li" href="https://www.linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
            <li class="list-inline-item"><a class="btn-git" href="https://github.com/XanaduAI"><i class="fab fa-github"> </i></a></li>
        </ul>
        <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">Stay updated with our newsletter</a>
    </div>
    <!--/.Social buttons-->

    <!--Copyright-->
    <div class="footer-copyright py-3 mt-0 text-center">
        <div class="container-fluid">
            © Copyright 2019 | Xanadu | All rights reserved
            <br>
             TensorFlow, the TensorFlow logo and any related marks are trademarks of Google Inc. 
        </div>
    </div>
  </footer>
  </body>
</html>